"""Tools for parsing the games generated by flo robot in hdf5 file"""

import json
import numpy as np


def parse_games(hdf5_file):
    """Parse the game data to determine the games that are present and
    when they start and finish

    start and finish are the first next command provided while the game
    was running and last next command provided while the game was running.

    Args:
        hdf5_file: The file to look in
    Returns: a dictionary with the game types, time the game was loaded,
             time the game was started, time the game finished.
    """
    #pylint: disable=too-many-locals
    # game_start_idx = np.where(
    #     hdf5_file['/game_runner/commands/data'][:] == b'start')
    game_finish_idx = np.where(
        hdf5_file['/game_runner/commands/data'][:] == b'finish_game')
    games = {}
    games['type'] = []
    games['type_time'] = []
    games['start'] = []
    games['finish'] = []

    # make sure that each end falls between the previous and next start
    # we want to find the first and last actions and work between those. Often times the game
    # is started well before any actions are occcuring and often the operator fails to stop
    # the game.

    # for each game definition, find the next next, that is the start
    # for each game definition, find the finish_game. If that finish_game
    # is after the next definition,
    # then set the end as the next definition find the last next prior to that end and call that the
    # end of the game.
    # The first next tells the robot to explain the game. The last one says congrats.
    # there is often a lot of robot movement before and after that
    next_command_mask = hdf5_file['/game_runner/commands/data'][:] == b'next'
    next_times = hdf5_file['/game_runner/commands/time'][next_command_mask]
    finish_times = hdf5_file['/game_runner/commands/time'][game_finish_idx]
    game_types = [json.loads(arr)['game_type']
                  for arr in hdf5_file['/game_runner/def/data']]
    def_times = hdf5_file['/game_runner/def/time'][:]
    num_games = len(game_types)

    for idx in range(num_games):
        nexts_after_start = np.flatnonzero(
            def_times[idx] < next_times)
        if len(nexts_after_start) == 0:
            continue
        first_next = next_times[nexts_after_start[0]]
        nexts_finish_idx = np.flatnonzero(finish_times > first_next)
        nexts_def_idx = np.flatnonzero(def_times > first_next)
        if len(nexts_finish_idx) == 0 and len(nexts_def_idx) == 0:
            final_nexts = [-1]
        elif len(nexts_finish_idx) == 0:
            next_def = def_times[nexts_def_idx[0]]
            final_nexts = np.flatnonzero(next_def > next_times)
        elif len(nexts_def_idx) == 0:
            next_finish = finish_times[nexts_finish_idx[0]]
            final_nexts = np.flatnonzero(next_finish > next_times)
        else:
            next_finish = finish_times[nexts_finish_idx[0]]
            next_def = def_times[nexts_def_idx[0]]
            final_nexts = np.flatnonzero(
                np.min([next_finish, next_def]) > next_times)

        if len(final_nexts) == 0:
            continue
        final_next = next_times[final_nexts[-1]]

        if final_next <= first_next:
            continue

        games['type'].append(game_types[idx])
        games['type_time'].append(def_times[idx])
        games['start'].append(first_next)
        games['finish'].append(final_next)

    return games
